{"meta":{"title":"玄銘的个人博客","subtitle":"试试事实上吗","description":"屏幕在深夜微微发亮，我心在远方","author":"玄銘","url":"https://sckrtge.github.io","root":"/"},"pages":[{"title":"关于本人","date":"2024-01-25T01:58:53.919Z","updated":"2024-01-25T01:58:05.283Z","comments":true,"path":"about.html","permalink":"https://sckrtge.github.io/about.html","excerpt":"","text":"自我介绍"},{"title":"我的朋友","date":"2024-01-25T02:00:46.490Z","updated":"2024-01-25T01:58:05.286Z","comments":true,"path":"friends.html","permalink":"https://sckrtge.github.io/friends.html","excerpt":"","text":"我的朋友"},{"title":"文章归档","date":"2024-01-25T01:58:58.636Z","updated":"2024-01-25T01:58:05.284Z","comments":true,"path":"archive.html","permalink":"https://sckrtge.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"四边形不等式优化dp小结","slug":"四边形不等式优化dp小结","date":"2024-01-25T08:15:12.956Z","updated":"2024-01-25T09:19:53.914Z","comments":true,"path":"2024/01/25/四边形不等式优化dp小结/","link":"","permalink":"https://sckrtge.github.io/2024/01/25/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96dp%E5%B0%8F%E7%BB%93/","excerpt":"","text":"定义 四边形不等式用于优化形如以下类型dp： 其中满足： 若有 若满足以上条件，约定表示对于来说最优决策点的位置，则有： 以上性质称为决策单调性。 两种基本方法 分治法 要求解所有状态，只需要求解所有最优决策点。为了对所有 求解 ，首先计算 ，而后分别计算 和 上的 ，注意此时已知前半段的 必然位于 和 之间（含端点），而后半段的 必然位于 和 之间（含端点）。对于两个子区间，也类似处理，直至计算出每个问题的最优决策。在分治的过程中记录搜索的上下边界，就可以保证算法复杂度控制在 。递归树层数为 ，而每层中，单个决策点至多计算两次，所以总的计算次数是 。 1234567891011int w(int j, int i);void DP(int l, int r, int k_l, int k_r) { int mid = (l + r) / 2, k = k_l; // 求状态f[mid]的最优决策点 for (int j = k_l; j &lt;= min(k_r, mid - 1); ++j) if (w(j, mid) &lt; w(k, mid)) k = j; f[mid] = w(k, mid); // 根据决策单调性得出左右两部分的决策区间，递归处理 if (l &lt; mid) DP(l, mid - 1, k_l, k); if (r &gt; mid) DP(mid + 1, r, k, k_r);} 二分队列 注意到对于每个决策点 ，能使其成为最小最优决策点的问题 必然构成一个区间。可以通过单调队列记录到目前为止每个决策点可以解决的问题的区间，这样，问题的最优解自然可以通过队列中记录的决策点计算得到。算法大致如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int val(int j, int i);int lt[N], rt[N], f[N];deque&lt;int&gt; dq;// 初始化队列dq.emplace_back(1);lt[1] = 1;rt[n] = n;// 顺次考虑所有问题和决策for (int j = 1; j &lt;= n; ++j) { // 出队 while (!dq.empty() &amp;&amp; rt[dq.front()] &lt; j) { dq.pop_front(); } // 计算 f[j] = val(dq.front(), j); // 入队 while (!dq.empty() &amp;&amp; val(j, lt[dq.back()]) &lt; val(dq.back(), lt[dq.back()])) { dq.pop_back(); } if (dq.empty()) { dq.emplace_back(j); lt[j] = j + 1; rt[j] = n; } else if (val(j, rt[dq.back()]) &lt; val(dq.back(), rt[dq.back()])) { if (rt[dq.back()] &lt; n) { dq.emplace_back(j); lt[j] = rt[dq.back()] + 1; rt[j] = n; } } else { int ll = lt[dq.back()]; int rr = rt[dq.back()]; int i; // 二分 while (ll &lt;= rr) { int mm = (ll + rr) / 2; if (val(j, mm) &lt; val(dq.back(), mm)) { i = mm; rr = mm - 1; } else { ll = mm + 1; } } rt[dq.back()] = i - 1; dq.emplace_back(j); lt[j] = i; rt[j] = n; }} 掌握这一算法，需要理解如下要点： 队列需要记录到目前为止每个可行的决策点 和能够解决的问题区间左右端点 和 构成的 三元组。对于给定区间 内的问题， 应该是到目前为止考虑过的决策点中最小最优的（以下简称最优决策）。每时每刻，队列中存储的决策未必是连续的，但是尚未解决的问题应该是队列中存储的问题区间的不交并。 初始化：将首个决策放于队列中，并记录它对于所有问题都是最优的。 类似于单调队列，每次考虑下一个决策 的时候，都需要进行出队和入队操作。 出队：当所有决策 都考虑结束后，问题 的解就是队列中首个满足 的决策点 。此时可以弹出所有满足 的队首。由于决策单调性，弹出的决策也不会是后续问题的最优决策。 入队：要对决策 进行入队时，首先比较它和队尾的决策 。 如果对于问题 ，将入队的决策 比已有的决策 更优，即 时，则弹出队尾的决策 。此操作持续到队尾的决策 比起 对于问题 更优时为止。 如果队列已空，入队 ，即认为决策 是尚未解决的所有问题的最优解。 如果队尾决策 对于问题 同样优于将入队的决策 ，那么当 时，入队 ，表示 是对于问题 的最优解，否则，不需要入队 ，因为它并不比已有的决策更优。 最后的情形是，队尾决策 比起要入队的决策 对于问题 更优，而对于问题 更劣，那么，需要通过 二分 找到最小的 使得 ，将队尾的区间右端点修改为 ，并入队 。 两种基本问题 区间分拆问题 考虑将某个区间拆分成若干个子区间的问题。形式化地说，将给定区间 拆分成 ，其中，，，以及 对任意 都成立。对于给定拆分，成本为 。问题要求最小化这一成本。可以列出如下的 1D1D 状态转移方程。 这里，。注意到，只要 满足四边形不等式， 必然满足四边形不等式，因为第一项并不包括 和 的交叉项，在混合差分时会消去。但是由于成本函数依赖于前面的子问题，这一转移只能够顺序计算，所以通常只适合应用二分队列算法。算法复杂度为 。 上述问题可以加强为限制区间个数的情形，即问题指定将区间拆分成 个子区间。此时需要将拆分后的区间个数作为转移状态的一维。相应地，有 2D1D 状态转移方程如下。 有以下引理： 若 满足四边形不等式，则 。 利用这一结果，我们可以限制决策 的搜索范围。算法实现时，对 正向遍历，对 逆向遍历，在之前已确定的上下界范围内暴力搜索 就可以保证 的算法复杂度。 另有wqs二分可以优化到。 区间合并问题 另一类可以通过四边形不等式优化的动态规划问题是区间合并问题，即要将 个长度为一的区间 两两合并起来，直到得到区间 。每次合并 和 时都需要支付成本 。问题要求找到成本最低的合并方式。对于此类问题，有如下 2D1D 状态转移方程。 这里给定任意初始成本 。 可以证明满足四边形不等式，且有以下定理： 利用这一结论，同样可以限制决策点 的搜索范围。在这里，正序遍历区间长度 ，再遍历具有同样长度的所有区间 ，暴力搜索 和 之间的所有 求得最优解 并记录最小最优决策 。总的算法复杂度为 。 参考资料 OI-Wiki 四边形不等式优化","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://sckrtge.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://sckrtge.github.io/tags/dp/"}]},{"title":"CSP2020","slug":"CSP2020游记","date":"2024-01-25T00:42:57.800Z","updated":"2024-01-25T00:52:51.034Z","comments":true,"path":"2024/01/25/CSP2020游记/","link":"","permalink":"https://sckrtge.github.io/2024/01/25/CSP2020%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"2020.10.11 初赛 早上起来头晕的要死，突然想到今天是初赛，感觉整个人都要裂开了。。。 然而还是只有强迫自己调整状态，终于还是调整过来了。 到了发现考场竟然是在小学一年级的教室里，真的无语了。。 这桌子还没有我的大腿高，难道CCF缺钱已经到了这种地步了？ 今年的卷子感觉难度还是跟昨年差不多，只不过坑点有点多。 1）一看不就是最大的，下一个。 2）只要不是用脚选，应该都不会选错 3）。 4）前几年的原题，但是换成了栈底，真tm坑。 5）一看等价直接选走人。 6）背包 7）又是一个原题。 8）好像还是原题。设左边有个点，右边有个点，，求，直接均值不等式，下一个。 9）常识，没有人错吧 10），但没必要，直接枚举，再看一下另外两个合不合法就可以了。 11）等差数列，，算一算就可以了。 12）转就可以了。 13）先选一个，有种，剩下的另一个还有个格子可以放，然后每对答案算了两遍除以2就可以了。 14）常识。 15）常识，而且又是原题。 16 - 20 实际上d[i]+d[j]-(d[i]&amp;d[j])就是d[i]|d[j]，然后就没有了。 21 - 25 只递归一边的快排，，然后没什么好说的。 26 - 30 好像是个双向，复杂度不会算（听说是），反正不太会。 31 - 35 就是个裸贪心，没什么好说的。 36 - 40 猜的答案，不过挺好猜的。（不过初值好像是） 考到一半的时候，外面竟然在放崩坏世界的歌姬，真tm离谱，这比赛的管理就这么差吗，不过歌好评。 2020.11.7 CSP-S T1 出题人你****，1582年后全过，1582年前爆炸珂海星，考试时想到了有1月0日，但是我判了1582年后，没有判1582年前，在洛谷炸成10分。 T2 十年竞赛一场空，开了也见祖宗。 考场上20分钟秒，但被卡了，也没啥说的。 T3 还好，由于sbT1耽误了太多的时间，所以打了个暴力，话说牛客的数据这个sb乱搞可以拿80分。 T4 考场上想出了一个可以过80分的做法，但是大样例有几个答案始终大1，有点崩，但还好有25分。 估分。 洛谷得分。 牛客得分。 这次出T1T2的人肯定心里黑暗，故意报复社会 T4暴力改出来了，在你谷有100分，一共只改了不到十个字符，我**** 感谢T1出题人数据放一条生路，实际得分：","categories":[{"name":"OI","slug":"OI","permalink":"https://sckrtge.github.io/categories/OI/"}],"tags":[]}],"categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://sckrtge.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"OI","slug":"OI","permalink":"https://sckrtge.github.io/categories/OI/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://sckrtge.github.io/tags/dp/"}]}